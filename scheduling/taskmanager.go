package scheduling

import (
	"context"
	"encoding/json"
	"fmt"
	"time"
)

const (
	TASTMETADATA    = "/tasks/metadata/task_id="
	TASKRUNS        = "/tasks/runs/task_id="
	TASKRUNMETADATA = "/tasks/runs/metadata"
)

func NewTaskManager(storage StorageProvider) TaskManager {
	return TaskManager{storage: storage}
}

type TaskManager struct {
	storage StorageProvider
}

type TaskMetadataList []TaskMetadata

func (tml *TaskMetadataList) ToJSON() string {
	return ""
}

// Task Methods
func (tm *TaskManager) CreateTask(name string, tType TaskType, target TaskTarget) (TaskMetadata, error) {
	// ids will be generated by TM
	return TaskMetadata{}, fmt.Errorf("Not implemented")
}

func (tm *TaskManager) GetTaskByID(id TaskID) (TaskMetadata, error) {
	key := fmt.Sprintf("%s%s", TASTMETADATA, string(id))
	metadata, err := tm.storage.Get(key, false)
	if err != nil {
		return TaskMetadata{}, err
	}

	if len(metadata) == 0 {
		return TaskMetadata{}, fmt.Errorf("Task not found for id: %s", string(id))
	}

	taskMetadata := TaskMetadata{}
	err = json.Unmarshal([]byte(metadata[0]), &taskMetadata)
	if err != nil {
		return TaskMetadata{}, err
	}
	return taskMetadata, nil
}

func (tm *TaskManager) GetTaskByTarget(target TaskTarget) (TaskMetadataList, error) {
	// need clarification on how to get the task by target
	// and what if the target has multiple tasks?
	// should we return a list of tasks?
	// or do we need to capture uniqueness in the target?
	return TaskMetadata{}, fmt.Errorf("Not implemented")
}

func (tm *TaskManager) GetAllTasks() (TaskMetadataList, error) {
	// get all the tasks
	metadata, err := tm.storage.Get(TASTMETADATA, true)
	if err != nil {
		return TaskMetadataList{}, err
	}

	tml := TaskMetadataList{}
	for _, m := range metadata {
		taskMetadata := TaskMetadata{}
		err = json.Unmarshal([]byte(m), &taskMetadata)
		if err != nil {
			return TaskMetadataList{}, err
		}
		tml = append(tml, taskMetadata)
	}
	return tml, nil
}

type TaskRunList []TaskRunMetadata

func (trl *TaskRunList) ToJSON() string {
	return ""
}

// Task Run Methods
func (t *TaskManager) CreateTaskRun(name string, taskID TaskID, trigger Trigger) (TaskRunMetadata, error) {
	return TaskRunMetadata{}, fmt.Errorf("Not implemented")
}

func (t *TaskManager) GetRunByID(id RunId) (TaskRunMetadata, error) {
	// should this be get runs based on task id?
	// or should it be get run by id?
	key := fmt.Sprintf("%s%s", TASKRUNMETADATA, string(id))
	return TaskRunMetadata{}, fmt.Errorf("Not implemented")
}

func (t *TaskManager) GetRunsByStatus(status Status) (TaskRunList, error) {
	// are we fine with looping through them all?
	return TaskRunList{}, fmt.Errorf("Not implemented")
}

func (t *TaskManager) GetRunsByResource(target TaskTarget) (TaskRunList, error) {
	return TaskRunList{}, fmt.Errorf("Not implemented")
}

func (t *TaskManager) GetRunsByTime(duration time.Duration) (TaskRunList, error) {
	// should this include start time or end time?
	return TaskRunList{}, fmt.Errorf("Not implemented")
}

func (t *TaskManager) GetAllTaskRuns() (TaskRunList, error) {
	return TaskRunList{}, fmt.Errorf("Not implemented")
}

// Write Methods
func (t *TaskManager) SetRunStatus(id RunID, status Status, err error) error {
	// we will need task id as well
	return fmt.Errorf("Not implemented")
}

func (t *TaskManager) SetRunStartTime(id RunID, time Time) error {
	// we will need task id as well
	return fmt.Errorf("Not implemented")
}

func (t *TaskManager) SetRunEndTime(id RunID, time Time) error {
	// we will need task id as well
	return fmt.Errorf("Not implemented")
}

func (t *TaskManager) AppendRunLog(id RunID, log string) error {
	// we will need task id as well
	return fmt.Errorf("Not implemented")
}

// Locking
func (t *TaskManager) LockTaskRun(ctx context.Context, runId RunId) error {
	// we will need task id as well
	return fmt.Errorf("Not implemented")
}

func (t *TaskManager) UnlockTaskRun(ctx context.Context, runId RunId) error {
	// we will need task id as well
	return fmt.Errorf("Not implemented")
}
